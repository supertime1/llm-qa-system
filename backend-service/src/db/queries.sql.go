// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: queries.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createQuestion = `-- name: CreateQuestion :one
INSERT INTO questions (
    patient_id,
    question_text,
    question_type,
    department,
    urgency_level,
    status
) VALUES (
    $1, $2, $3, $4, $5, 'STATUS_PENDING'
) RETURNING id, patient_id, question_text, question_type, department, urgency_level, status, created_at, answered_at, answered_by
`

type CreateQuestionParams struct {
	PatientID    pgtype.UUID `json:"patient_id"`
	QuestionText string      `json:"question_text"`
	QuestionType string      `json:"question_type"`
	Department   string      `json:"department"`
	UrgencyLevel pgtype.Int4 `json:"urgency_level"`
}

// Patient operations
func (q *Queries) CreateQuestion(ctx context.Context, arg CreateQuestionParams) (Question, error) {
	row := q.db.QueryRow(ctx, createQuestion,
		arg.PatientID,
		arg.QuestionText,
		arg.QuestionType,
		arg.Department,
		arg.UrgencyLevel,
	)
	var i Question
	err := row.Scan(
		&i.ID,
		&i.PatientID,
		&i.QuestionText,
		&i.QuestionType,
		&i.Department,
		&i.UrgencyLevel,
		&i.Status,
		&i.CreatedAt,
		&i.AnsweredAt,
		&i.AnsweredBy,
	)
	return i, err
}

const getAnswerHistory = `-- name: GetAnswerHistory :many
SELECT 
    q.id as question_id,
    q.question_text,
    q.question_type,
    q.department,
    a.answer_text as answer,
    q.status,
    q.created_at,
    a.created_at as answered_at,
    d.name as answered_by
FROM questions q
LEFT JOIN answers a ON q.id = a.question_id
LEFT JOIN doctors d ON a.doctor_id = d.id
WHERE q.patient_id = $1
    AND ($2::question_status IS NULL OR q.status = $2)
    AND ($3::timestamptz IS NULL OR q.created_at >= $3)
    AND ($4::timestamptz IS NULL OR q.created_at <= $4)
ORDER BY q.created_at DESC
LIMIT $5 OFFSET $6
`

type GetAnswerHistoryParams struct {
	PatientID pgtype.UUID        `json:"patient_id"`
	Column2   interface{}        `json:"column_2"`
	Column3   pgtype.Timestamptz `json:"column_3"`
	Column4   pgtype.Timestamptz `json:"column_4"`
	Limit     int32              `json:"limit"`
	Offset    int32              `json:"offset"`
}

type GetAnswerHistoryRow struct {
	QuestionID   pgtype.UUID        `json:"question_id"`
	QuestionText string             `json:"question_text"`
	QuestionType string             `json:"question_type"`
	Department   string             `json:"department"`
	Answer       pgtype.Text        `json:"answer"`
	Status       string             `json:"status"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	AnsweredAt   pgtype.Timestamptz `json:"answered_at"`
	AnsweredBy   pgtype.Text        `json:"answered_by"`
}

func (q *Queries) GetAnswerHistory(ctx context.Context, arg GetAnswerHistoryParams) ([]GetAnswerHistoryRow, error) {
	rows, err := q.db.Query(ctx, getAnswerHistory,
		arg.PatientID,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAnswerHistoryRow{}
	for rows.Next() {
		var i GetAnswerHistoryRow
		if err := rows.Scan(
			&i.QuestionID,
			&i.QuestionText,
			&i.QuestionType,
			&i.Department,
			&i.Answer,
			&i.Status,
			&i.CreatedAt,
			&i.AnsweredAt,
			&i.AnsweredBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAnswerHistoryCount = `-- name: GetAnswerHistoryCount :one
SELECT COUNT(*)
FROM questions
WHERE patient_id = $1
    AND ($2::question_status IS NULL OR status = $2)
    AND ($3::timestamptz IS NULL OR created_at >= $3)
    AND ($4::timestamptz IS NULL OR created_at <= $4)
`

type GetAnswerHistoryCountParams struct {
	PatientID pgtype.UUID        `json:"patient_id"`
	Column2   interface{}        `json:"column_2"`
	Column3   pgtype.Timestamptz `json:"column_3"`
	Column4   pgtype.Timestamptz `json:"column_4"`
}

func (q *Queries) GetAnswerHistoryCount(ctx context.Context, arg GetAnswerHistoryCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, getAnswerHistoryCount,
		arg.PatientID,
		arg.Column2,
		arg.Column3,
		arg.Column4,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getPendingReviews = `-- name: GetPendingReviews :many
SELECT 
    q.id as question_id,
    q.patient_id,
    q.question_text,
    q.question_type,
    q.department,
    q.urgency_level,
    a.ai_draft_answer,
    a.ai_confidence,
    a.ai_references,
    q.created_at
FROM questions q
LEFT JOIN answers a ON q.id = a.question_id
WHERE q.status = 'STATUS_PENDING_REVIEW'
    AND ($1::department IS NULL OR q.department = $1)
    AND ($2::question_type IS NULL OR q.question_type = $2)
    AND ($3::int IS NULL OR q.urgency_level >= $3)
    AND ($4::timestamptz IS NULL OR q.created_at >= $4)
    AND ($5::timestamptz IS NULL OR q.created_at <= $5)
ORDER BY q.urgency_level DESC, q.created_at ASC
LIMIT $6 OFFSET $7
`

type GetPendingReviewsParams struct {
	Column1 interface{}        `json:"column_1"`
	Column2 interface{}        `json:"column_2"`
	Column3 int32              `json:"column_3"`
	Column4 pgtype.Timestamptz `json:"column_4"`
	Column5 pgtype.Timestamptz `json:"column_5"`
	Limit   int32              `json:"limit"`
	Offset  int32              `json:"offset"`
}

type GetPendingReviewsRow struct {
	QuestionID    pgtype.UUID        `json:"question_id"`
	PatientID     pgtype.UUID        `json:"patient_id"`
	QuestionText  string             `json:"question_text"`
	QuestionType  string             `json:"question_type"`
	Department    string             `json:"department"`
	UrgencyLevel  pgtype.Int4        `json:"urgency_level"`
	AiDraftAnswer pgtype.Text        `json:"ai_draft_answer"`
	AiConfidence  pgtype.Float8      `json:"ai_confidence"`
	AiReferences  []string           `json:"ai_references"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
}

// Doctor operations
func (q *Queries) GetPendingReviews(ctx context.Context, arg GetPendingReviewsParams) ([]GetPendingReviewsRow, error) {
	rows, err := q.db.Query(ctx, getPendingReviews,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPendingReviewsRow{}
	for rows.Next() {
		var i GetPendingReviewsRow
		if err := rows.Scan(
			&i.QuestionID,
			&i.PatientID,
			&i.QuestionText,
			&i.QuestionType,
			&i.Department,
			&i.UrgencyLevel,
			&i.AiDraftAnswer,
			&i.AiConfidence,
			&i.AiReferences,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingReviewsCount = `-- name: GetPendingReviewsCount :one
SELECT COUNT(*)
FROM questions
WHERE status = 'STATUS_PENDING_REVIEW'
    AND ($1::department IS NULL OR department = $1)
    AND ($2::question_type IS NULL OR question_type = $2)
    AND ($3::int IS NULL OR urgency_level >= $3)
    AND ($4::timestamptz IS NULL OR created_at >= $4)
    AND ($5::timestamptz IS NULL OR created_at <= $5)
`

type GetPendingReviewsCountParams struct {
	Column1 interface{}        `json:"column_1"`
	Column2 interface{}        `json:"column_2"`
	Column3 int32              `json:"column_3"`
	Column4 pgtype.Timestamptz `json:"column_4"`
	Column5 pgtype.Timestamptz `json:"column_5"`
}

func (q *Queries) GetPendingReviewsCount(ctx context.Context, arg GetPendingReviewsCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, getPendingReviewsCount,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getQuestionStatus = `-- name: GetQuestionStatus :one
SELECT 
    q.id, q.patient_id, q.question_text, q.question_type, q.department, q.urgency_level, q.status, q.created_at, q.answered_at, q.answered_by,
    a.answer_text,
    a.doctor_id as answered_by
FROM questions q
LEFT JOIN answers a ON q.id = a.question_id
WHERE q.id = $1 AND q.patient_id = $2
LIMIT 1
`

type GetQuestionStatusParams struct {
	ID        pgtype.UUID `json:"id"`
	PatientID pgtype.UUID `json:"patient_id"`
}

type GetQuestionStatusRow struct {
	ID           pgtype.UUID        `json:"id"`
	PatientID    pgtype.UUID        `json:"patient_id"`
	QuestionText string             `json:"question_text"`
	QuestionType string             `json:"question_type"`
	Department   string             `json:"department"`
	UrgencyLevel pgtype.Int4        `json:"urgency_level"`
	Status       string             `json:"status"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	AnsweredAt   pgtype.Timestamptz `json:"answered_at"`
	AnsweredBy   pgtype.UUID        `json:"answered_by"`
	AnswerText   pgtype.Text        `json:"answer_text"`
	AnsweredBy_2 pgtype.UUID        `json:"answered_by_2"`
}

func (q *Queries) GetQuestionStatus(ctx context.Context, arg GetQuestionStatusParams) (GetQuestionStatusRow, error) {
	row := q.db.QueryRow(ctx, getQuestionStatus, arg.ID, arg.PatientID)
	var i GetQuestionStatusRow
	err := row.Scan(
		&i.ID,
		&i.PatientID,
		&i.QuestionText,
		&i.QuestionType,
		&i.Department,
		&i.UrgencyLevel,
		&i.Status,
		&i.CreatedAt,
		&i.AnsweredAt,
		&i.AnsweredBy,
		&i.AnswerText,
		&i.AnsweredBy_2,
	)
	return i, err
}

const saveAIDraftAnswer = `-- name: SaveAIDraftAnswer :one
INSERT INTO answers (
    question_id,
    ai_draft_answer,
    ai_confidence,
    ai_references,
    review_status
) VALUES (
    $1, $2, $3, $4, 'DECISION_UNSPECIFIED'
)
RETURNING id, question_id, doctor_id, answer_text, ai_draft_answer, ai_confidence, ai_references, review_status, review_comment, created_at, updated_at
`

type SaveAIDraftAnswerParams struct {
	QuestionID    pgtype.UUID   `json:"question_id"`
	AiDraftAnswer pgtype.Text   `json:"ai_draft_answer"`
	AiConfidence  pgtype.Float8 `json:"ai_confidence"`
	AiReferences  []string      `json:"ai_references"`
}

func (q *Queries) SaveAIDraftAnswer(ctx context.Context, arg SaveAIDraftAnswerParams) (Answer, error) {
	row := q.db.QueryRow(ctx, saveAIDraftAnswer,
		arg.QuestionID,
		arg.AiDraftAnswer,
		arg.AiConfidence,
		arg.AiReferences,
	)
	var i Answer
	err := row.Scan(
		&i.ID,
		&i.QuestionID,
		&i.DoctorID,
		&i.AnswerText,
		&i.AiDraftAnswer,
		&i.AiConfidence,
		&i.AiReferences,
		&i.ReviewStatus,
		&i.ReviewComment,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const submitReview = `-- name: SubmitReview :one
WITH updated_question AS (
    UPDATE questions
    SET status = $2
    WHERE id = $1
    RETURNING id
)
INSERT INTO answers (
    question_id,
    doctor_id,
    answer_text,
    ai_draft_answer,
    review_status,
    review_comment
) VALUES (
    $1, $3, $4, $5, $6, $7
)
RETURNING id, question_id, doctor_id, answer_text, ai_draft_answer, ai_confidence, ai_references, review_status, review_comment, created_at, updated_at
`

type SubmitReviewParams struct {
	QuestionID    pgtype.UUID `json:"question_id"`
	Status        string      `json:"status"`
	DoctorID      pgtype.UUID `json:"doctor_id"`
	AnswerText    string      `json:"answer_text"`
	AiDraftAnswer pgtype.Text `json:"ai_draft_answer"`
	ReviewStatus  string      `json:"review_status"`
	ReviewComment pgtype.Text `json:"review_comment"`
}

func (q *Queries) SubmitReview(ctx context.Context, arg SubmitReviewParams) (Answer, error) {
	row := q.db.QueryRow(ctx, submitReview,
		arg.QuestionID,
		arg.Status,
		arg.DoctorID,
		arg.AnswerText,
		arg.AiDraftAnswer,
		arg.ReviewStatus,
		arg.ReviewComment,
	)
	var i Answer
	err := row.Scan(
		&i.ID,
		&i.QuestionID,
		&i.DoctorID,
		&i.AnswerText,
		&i.AiDraftAnswer,
		&i.AiConfidence,
		&i.AiReferences,
		&i.ReviewStatus,
		&i.ReviewComment,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
